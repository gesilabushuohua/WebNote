# Javascript 基础

## 执行上下文/作用域链/闭包
执行上下文 js 代码执行的环境抽象概念
js 代码执行时，会创建一个全局执行上下文压入上下文栈，调用函数时创建函数上下文压入上下文栈中，每个上下文都有三个属性变量对象（定义的变量和函数声明）、作用域（变量的访问权限[scope]）、this 变量指向的作用域。
作用域链时由（多个执行上下文的变量对象构成的链表）叫做作用域链。


### 介绍下 Javascript 的执行上下文
执行上下文，js 代码执行的环境的抽象概念；
类型分为三种
* 全局执行上下文，任何不在函数内部的代码；
* 函数执行上下文，函数调用时创建；
* Eval 函数执行上下文，eval 内部代码会有属于自己的执行上下文；
js 引擎创建执行上下文栈来管理执行上下文。
执行栈，其他编程语言中的调用栈，拥有后进先出数据结构的栈，用来存储代码运行时创建的所执行执行上下文。
当执行一个函数时，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。


### Javascript 静态作用域
作用域代码中定义变量的区域。
作用域规定了如何查找变量，确定当前执行代码对变量的访问权限。
js 采用词法作用域，也就是静态作用域，函数的作用域在函数定义的时候就觉得了，动态作用域，函数的作用域时在函数调用的时候才决定的。
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope(); // local scope
checkscope(); // local scope
```
js 采用的是词法作用域，函数的作用域基于函数创建的位置

#### 变量对象
变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。
不同执行上下文，变量对象也不同，例如全局上下文变量对象和函数上下文的变量对象。
#### 全局上下文
全局上下文的变量对象就是全局对象。

#### 函数上下文
在函数上下文中，用活动对象来表示变量对象。
活动对象和变量对象其实是一个东西，只是对量对象是规范上的或者说是引擎实现上的，不可在 javascript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能访问。
活动对象是在进入函数上下文时刻被创建，通过函数的 argument 属性初始化，argument 属性值是 Argument 对象。

#### 执行过程
* 全局上下文的变量对象初始化是全局对象
* 函数上下文的变量对象初始化只包括 Argument 对象
* 在进入执行上下文时，会给变量对象添加形参、函数声明、变量声明等初始化的属性值
* 在代码执行阶段，会再次修改变量对象的属性值


### 介绍下 Javascript 的作用域链
当每个 Javascript 代码执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性：
* 变量对象
* 作用域
* this（后序描述）
作用域链是由多个执行上下文的变量对象构成的链表。即当查找变量的时候，会从当前上下文的变量对象中查找，如果没有查找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。

https://github.com/mqyqingfeng/Blog/issues/6

#### 函数执行上下文作用域和变量对象的创建过程
1. checkscope 函数创建，保存作用域到内部属性[[scope]]；
2. 执行 checkscope 函数，创建函数 执行上下文，函数执行上下文被压入执行上下文栈；
3. 函数并不立刻执行，开始准备工作，第一步，复制函数[[scope]]属性 创建作用域；
4. 第二步，用 argument 创建活动对象，随后初始化对象，加入形参、函数声明、变量声明；
5. 第三步，将活动对象压入 checkout 作用域链顶端
6. 准备工作做完，开始执行函数，随着函数执行，修改 AO 的属性值；
7. 查找到 scope2 的值，返回函数执行完毕，函数上下文从执行上下文栈中弹出。


### 介绍下 Javascript 的闭包，及应用场景
闭包是一个可以访问外部作用域的内部函数。
即使这个外部作用域已经执行结束，即闭包就是引用外部作用域中变量的函数，被引用的变量知道闭包被销毁时才会被销毁。
闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。
通过闭包，可以创建拥有私有状态的函数，闭包使得状态被封装起来。

闭包造成内存泄漏 ？？？？
文章论证，引用计数导致的 ？ ie9 有
现在用的标记清除，没有内存泄漏



## 内存
### 变量的存放
基本类型，保存在栈内存中，这些类型分别占有股东大小的空间
引用类型，因为大小不固定，保存在堆内存中。查询引用类型变量的时候，先从栈中读取内存地址，然后在通过地址找到堆中的值

### 内存空间管理
生命周期：
* 分配所需的内存
* 使用分配的内存
* 不需要时将其释放、归还

Javascript 有自动垃圾收集机制，最常用的是通过标记清除算法来找到哪些对象不再继续使用。 a = null 做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，值回在下一次垃圾收集器执行操作时被找到并释放。
在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收，但是全局变量什么时候需要自动释放内存很难判断，因此在开发中，需要尽量避免使用全局变量。
闭包中的变量保存在堆内存中，所以函数之后为什么闭包还能引用到函数内的变量。

### 内存回收
Javascript 有自动垃圾回收机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再使用的值，然后释放其占用的内存。
* 布局变量，局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收
* 全局变量，什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量

常用的回收算法有两种：
引用计数，（现代浏览器不再使用），是否回收数据，就看一个对象是否指向它的引用，但有一只致命问题，就是循环使用，若两个对象相互引用，尽管他们不再使用，但是垃圾回收器不会进行回收，最终导致内存泄漏
标记清除，将不再使用的对象定义为无法到达的对象，从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留，否则标记为不再使用，稍后进行回收。


### 内存泄漏
浏览器检查方法：
* 打开开发者工具，选择 Memory
* 打开右侧的 Select profiling type 字段力勾选 timeline
* 点击左上角的录制按钮
* 在页面上进行各种操作，模拟用户的使用情况
* 一段时间后，点击左上角的 stop 按钮，面板上会显示这段时间的内存占用情况

常见内存泄漏
* 意外全局变量，为定义变量会在全局对象创建一个新变量
* 遗忘的计时器或事件注册的回调函数（onclick）
* 脱离 DOM 引用，把 DO M 存成阻断，或者数组，需要手动清除
* 闭包，关键是匿名函数可以访问父级作用域的变量

### 内存优化
函数挂载原型，只创建一次，是 js 内存设计的
https://hijiangtao.github.io/2018/08/21/Prototypes/



## this/call/apply/bind

### 介绍下 Javascript 的 this
this 的指向时函数怎样调用，会导致 this 的指向会让人迷惑，简单凯说，this 具有运行期绑定的特性。
* 全局上下文，this 指向全局对象
* 函数上下文，this 值取决于函数被调用的方式
  直接调用，this 指向全局变量
  call\apply this 指向绑定的对象上
  bind this 绑定到第一参数
* 箭头函数, 没有自己的 this， 都指向外层
* 对象方法，this 指向调用函数的对象
  ```javascript
  var name = "xb";
  var person = {
    name: "axuebin",
    getName: function(){
        return this.name;
    }
  };
    var getName = person.getName;
    // this 指向得看函数调用时
    console.log(getName()); // xb
  ```
* 构造函数，this 指向正在构建的新对象
* DOM 事件处理函数，this 指向触发事件的元素，始事件处理程序所绑定的 DOM  节点
* HTML 标签内联事件处理函数，this 指向所在的 DOM 元素
* jQuery，this 大部分情况都指向 DOM 元素节点
总结，函数的 this 指向，由函数直接调用位置决定，可以根据以下四个规则判断：
* 由 new 调用，绑定到新创建的对象
* 由 call、apply、bind 调用，绑定到指定的对象
* 由上下文对象调用，绑定到上下文对象
* 默认，全局对象


#### 从 ECMAScript 规范解读this
当每个 Javascript 代码执行一段可执行代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性：
* 变量对象
* 作用域
* this

没太看懂 https://github.com/mqyqingfeng/Blog/issues/7

规格说明 http://www.ruanyifeng.com/blog/2015/11/ecmascript-specification.html
规格文件是计算机语言的官方标准，详细描述语法规则和实现方法，一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，是在找不到答案，可以查看规格文件，了解语言标准时怎么说的。规格是解决问题的最后一招。
这对 js 语言很有必要，因为使用的场景复杂，语法规则不同意，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法都不可能囊括所有情况，查看规格，不失为一种解决语法问题最可靠、去求安慰的终极方法。


### 如何改变 this 的指向
call、apply、bind 可以改变 this 的指向

### call/apply/bind 区别
* 三者都是用来改变函数 this 指向
* 三者第一参数都是 this 指向的对象
* bind 是返回一个绑定函数可稍后执行，call、apply 是立即调用
* 三者第一可以给定参数传递
* call 给定惨呼需要将参数全部列出， apply 给定参数数组

### call 实现
// Function.prototype.call
// this 非 function 抛出 TypeError
// this 指向第一个参数（可为null），其他参数一一排，返回 fn 执行结果
```javascript
Function.prototype.myCall=function(context){
    if(typeof this !== 'function') {
        throw new TypeError(this+'must be a function');
    }
    // context 不存在，则为 window
    const context = context || window;
    // 也存在覆盖问题
    //context.fn = this;
    context = context || window;
    const key = `${new Date().getTime()}fn`;
    context[key] = this;
    const args = Array.prototype.slice.call(argument,1);
    let res = undefined;
    res = args ? context[key](...args) : context[key]();
    delete context[key];
    return res;
}
```
可实现继承
```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.say = function() {
        console.log(this.name,',',this.age);
    }
}
function Student(name,age,job) {
    Person.call(this,name,age);
    this.say=function(){
        console.log(this.name,',',this.age,',',this.job);
    }
}
```

### apply 实现
// Function.prototype.apply
// this 指向第一个参数（可为null 指向window），第二参数为数组，返回 fn 执行结果
```javascript
Function.prototype.myApply=function(context) {
   if(typeof this !== 'function') {
        throw new TypeError(this+'must be a function');
    }
    context = context || window;
    // 同名被覆盖问题，使用 'fn'+new Date().getTime 区分
    const key = `${new Date().getTime()}fn`;
    context[key] = this;
    const args = argument[1];
    // 结构 使用 new Function 替换
    const res = arges ? context[key](...arges) : context[key]();
    delete context[key];
    return res;
}

```
### bind 实现
// Function.prototype.bind
// 可传参，返回值是函数，函数名是 'bound '，可传参，合并处理
// 返回函数执行值，是原函数的返回值
// new bound 返回值，是以 fn 原函数构造器生成的新对象
```javascript
Function.prototype.bind=function(context){
    if(typeof this !== 'function') {
        throw new TypeError(this + 'must be a function');
    }
    // 存储调用 bind 的函数本身
    const self = this;
    const args = Array.slice.call(argument,1);
    const bound = function() {
        // bind 返回的函数参数转数组
        const boundArgs = [...args, ...Array.slice.call(arguments))];
        // new bound 返回值，是以 fn 原函数构造器生成的新对象
        // 验证对象是否通过构造函数使用 new 实例出来的
        // 判断是否是用 bound new 实例化的
        if(this instanceof bound) {
            /** 创建一个新对象
                执行 [[Prototype]] 链接
                通过 new 创建的每个对象最终被 [[prototype]] 
                链接到这个函数的 prototype 对象上 
            **/
            // self 可能是 ES6 的箭头函数，没有 prototype，没有必要再指向做 prototype 操作
            if(self.prototype)  { 
                // ES5 提供方案 Object.create()
                bound.prototype = Object.create(self.prototype)
                // function Empty() {}
                // Empty.prototype = self.prototype;
                // bound.prototype = new Empty();
            }
            // 生产的心对象绑定到函数调用的 this 上
            const result = self.apply(this, boundArgs);
            // 如果函数没有返回对象类型 Object （包含 Function、Array、Date、RegExg、Error）
            // new 表达式中的函数调用会自动返回这个新的对象
            const isObject = typeof result === 'object' && result !== null;
            const isFunction = typeof result === 'function';
            if(isObject || isFunction) {
                return result;
            }
            return this;
        } else {
            // apply 修改 this 指向，把两函数参数合并，执行 self 函数， 返回结果
            return self.apply(context, boundargs);
        }
    }
    return bound;
}
```
不允许使用 call\apply 则自己定义两函数

## 原型/继承
[__proto__] 和 constructor 是对象独有的，prototype 属性是函数独有的，在 Javascript 中，函数也是对象，所以函数也拥有 [__proto__] 和 constructor，函数的构造函数指向 new Function.

### 介绍下 Javascript 的原型
函数的 prototype 使用构造函数而创建的实例原型
每个对象有 [__proto__] 属性，叫原型, 指向构造函数的 prototype，每个 function 有 prototype，指为其他对象提供共享属性访问的对象。
所有 javascript 对象都从原型继承属性和方法。

### 原型链是什么
每个对象都有一个原型对象，通过 [__proto__] 指针指向上一个原型，并从中继承方法和属性，同时原型对象也可以拥有原型，这样一层层，最终指向 null，这就是原型链。

### typeof && instanceof 原理
#### typeof
typeof 判断 number、undefined、symbol、string、function、boolean、object 七种数据类型，但是不能判断 object 属于哪一种 object。
Javascript 中的值是由一个表示类型的标签和实际数据值表示的。
底层存储变量的时候，会在变量的机器的低位1-3位存储其类型信息。
* 1 正数
* 110 布尔值
* 100 字符串
* 010 浮点数
* 000 对象
* null 所有机器码均为 0
* undefined 用 -2^30 整数来表示

#### instanceof
instanceof 运算符来检测 constructor.prototype 是否存在于参数 object 的原型链上。
```javascript
function instance_of(L, R){
    const o = R.prototype; // 取R显示原型
    L = L.__proto__; // 取 L 的隐式原型
    while(true) {
        if(L===null) return false;
        if(o===L) return true;
        L = L.__proto__;
    }
}
```

#### new.target
new.target 属性允许检测函数或构造方法是否通过 new 运算符被调用，在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用，在普通函数调用中，new.target 的值是 undefined。

### 如何利用原型实现继承
继承，子类访问到 parent 构造函数里的属性，访问到 parent.prototype 中的属性。
继承意味着复制操作，然而 Javascript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，与其叫做继承，委托的说法更准确。

### 构造函数
constructor 返回创建实例对象，引用构造函数，属性值时对函数本身的引用，而不是包含函数名称的字符串。
Symbol 是基本数据类型，作为构造函数并不完整，因为不支持语法 new Symbol()，chrome 认为其不是构造函数，如果要生成实例直接使用 Symbol() 即可。
constructor 属性值是可以修改的，但是对于基本类型来说是只读的，🌰，在原型链继承方案中，对 constructor 重新赋值进行修正。


### new
// 创建对象
// prototype 指向 父类
// apply 修改 this 指向
// 返回对象
```javascript
function myNew(obj) {
  const o = {};
  o.prototype = Object.cretate(obj.protptype);
  return o;
}
```


### class
 ES6 为了更接近传统语言的写法，引入了 Class 的概念，作为对象的模板。基本上 ES6 的 class 可以只看作一个语法糖，让对象的原型写法更加清晰、更像面向对象编程的语法，完全可以看作构造函数的另一种写法。
 在 class 内部可以使用，get\set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为

### class extend 的继承，与原型链继承的区别
子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。
extend 关键字，关键代码在于
```javascript
_inherits(Child,_parent);
_this = _possibleConstructorReturn(this, _getPrototypeOf(Child).call(this, name));
```

### function 箭头函数 区别
* 箭头函数没有 arguments
* 箭头函数 this 指向外层环境，function  this 取决定义和调用方式
* 箭头函数，没有 prototype，使用 new 构造会报错

### 延伸
基于 prototype 和 class 编写的代码，很难通过代码分析，在构建时进行移除不必要的代码，这项技术叫 Tree-Shaking 或者 Dead code Elimination，实现原理查阅 babel webpack plugin 篇。



## Promise
### 异步
js 在浏览器中单线程设计避免，多个线程对同个 DOM 节点操作，设计为单线程，为了避免图片资源加载时，阻塞现场，设计了异步非阻塞。
js 是单线程，但是浏览器不是，只是执行 js 代码的引擎是单线程，但是浏览器不是，只是执行 js 代码的引擎是个单线程的，所以 js 代码没有办法开启多个线程，所以在执行定时器、事件、ajax 这些异步事件的时候是另外三个线程在执行代码，并不是 js 引擎在执行，在这些线程达到某一特定事件把任务放入 js 引擎线程中，同时 GUI 线程（渲染界面 HTML 的线程）与 JS 线程是互斥的，在 JS 引擎执行时 GUI 线程会被冻结、挂起。
js 在 node 中，单线程？多线程？现有方案是如何实现多线程的

### promise 是什么
承诺一段时间会返回一个结果，理解为一种 callback management
promise 是通过 then 方法去注册 callbacks
.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续 .catch 捕获，需要改成以下一种
```javascript
return Promise.reject(new Error('error!!!'))
throw new Error('error!!!')
```
then 或者 catch 的参数期待是函数，传入非函数则会发生值穿透
```javascript
Promise.resolve(1)
.then(2)
.then(Promise.resolve(3))
.then(console.log) // 打印 1
```

### 如何实现一个 Promise（Promise A+）
规则
* new Promise((resolve,reject)=>{}), return Object
* 状态 pedding fuilled rejected
* function resolve(val) { val, // 注册的执行成功回调 }
* function rejected(err) { err, // 注册的执行失败回调 }
* 支持同步、异步，使用 setTimeout
* then(onfulfilledfn,onRejectedfn) 注册实例成功和失败回调
* 支持链式回调，callbacks， return promise2
* 串式回调函数， resolvePromise(promise2,x,resolve,reject);
* promise2 !== x，任何异常执行 catch，
* x 不能是 null
* x 是普通值，直接 resolve(x)
* x 是对象或者函数， 包括 promise，let then = x.then
* resolvePromise 异常走 reject

// 不看文章自己实现


### Promise 方法
Promise.resolve Promisr.reject Promise.all Promise.race
https://juejin.cn/post/6844903617619558408#heading-34

#### Promise.all
执行所有 promise 返回
// return i === length && resolve(res[i])


#### Promise.race 
返回最先执行完成的
// return promises[i].then(res => resolve(res));

#### promiseify
将函数定义为 promise 

### async await
es6 语法糖
通过 async/await 关键字，将 Promise + generator 语意化和标准化的产物。

async/await 遇上 forEach
```javascript
var getNumbers = () => {
  return Promise.resolve([1, 2, 3])
}
var multi = num => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (num) {
        resolve(num * num)
      } else {
        reject(new Error('num not specified'))
      }
    }, 1000)
  })
}
async function test () {
  var nums = await getNumbers()
  nums.forEach(async x => {
    var res = await multi(x)
    console.log(res)
  })
}
test() // 1 秒后，一次性输出 1，4，9，期待 每间隔 1 秒依次输出 1，4，9 串行执行

// 自定义 forEach， 改写为 async await
// 改用 for of, for-of 实现迭代器方法，使用迭代器对象上的 next 方法，done 表示遍历是否结束
```

## 深浅拷贝
### Javascript 中深浅拷贝是什么
数据类型分为基本数据类型，引用数据类型，基础类型值保存在栈内存中的简单数据段，引用数据类型保持在堆内。
对于基本数据类型的拷贝，没有深浅拷贝的区别，深浅拷贝都是对引用数据类型而言。
浅拷贝，复制对象引用，两对象指向同一存储地址，拷贝对象变化，原对象也发生变化；
深拷贝，复制对象属性，指向同一存储地址


### 如何实现浅拷贝
浅拷贝，简单利用 = 赋值实现一个浅拷贝。

### 如何实现深拷贝
目前实现拷贝方式主要有两种
#### parse、stringify
利用 JSON 对象中的 parse、stringify，但只适合简单对象
* undefined、任意函数、正则表达式类型以及 sybol 值，在序列化过程中会被忽视
* 抛弃对象 constructor，拷贝后会变成 Object
* 循环引用报错

#### 递归
利用递归来实现每一层都重新创建对象并赋值

进阶，使用 hasOwnProperty 是否属于对象原型
```javascript
    if (source.hasOwnProperty(i)) {
        if (typeof source[i] === 'object') {
            target[i] = clone(source[i]); // 递归判断
        } else {
            target[i] = source[i];
        }
    }
```
上面代码问题：
* 没有对参数校验，参数为 null 时，应返回 null
* 判断是否对象的逻辑不够严谨，typeof null === 'object'，使用 
  ```javascript
  Object.prototype.toString.call(obj) === '[object Object]';
  ``` 
* 没有考虑数组的兼容
```javascript
if(typeof obj === 'object' && obj != null)
// 保留数组
if(Object.prototype.hasOwnProperty.call(source,key));
// 递归执行
```
* 递归方法，容易爆栈，借助栈，深度优先，遍历树
* 未解决循环引用，可已通过 JSON.parse(JSON.stringify(source)) 检验是否循环引用
* 破解循环引用，使用 === 判断是否已经拷贝过

优化
```javascript
function deepClone(x) {
  const weapMap = new WeakMap();
  // 拷贝数据
  let root = {};

  // 循环数组
  const loopList = [{
    parent: root,
    key: undefined,
    data: x
  }];

  while(loopList.length) {
    // 深度优先
    const node = loopList.pop();
    const { parent, key, data } = node;
    
    // 初始化赋值目标，key 为 undefined 则拷贝到父元素，否则拷贝到子元素
    let res = parent;
    typeof key !== 'undefined' && (res = parent[key] = {});

    // 如果数据已存在
    if(weapMap.has(data)) {
      parent[key] = weapMap.get(data);
      continue; // 中断本次循环
    }

    if (!data) {
      continue;
    }

    // 数据不存在，保存数据源，拷贝数据中对应的引用
    weapMap.set(data, res);

    for(let k in data) {
      if(data.hasOwnProperty(k)) {
        if(typeof data[k] === 'object') {
          
          // 下次循环
          loopList.push({ parent: res, key: k, data: data[k]});
        }else {
          res[k] = data[k];
        }
      } 
    }
  }
  return root;

}

const obj = { a: 1, b: 2, c: { d: 3 } };
const copy = deepClone(obj);

console.log({ obj, copy });
```

### 实现深浅拷贝需要注意哪些问题
深拷贝
* 属性是否属于本身
* 数组拷贝
* 数据环形引用


### 如何解决循环引用问题
通过去重

## 事件机制/Event Loop
### 基本概念
js 运行
* 执行引擎，编译并执行 js 代码，完成内存分配、垃圾回收等
* 执行环境，为 js 提供一些对象，或机制，使它能够与外界交互

浏览器（多进程）包含了 Browser 进程（浏览器的主进程）、第三方插件进程和GPU 进程（浏览器渲染进程），其中GPU进程（多线程）和Web前端相关，包含以下线程：
* GUI 渲染线程
* JS 引擎线程
* 事件触发线程（和 EventLoop 密切相关）
* 定时器触发线程
* 异步 HTTP 请求线程

GUI 渲染线程和JS引擎线程是互斥的，为了防止 DOM 渲染的不一致，其中一个线程执行时另一个线程会被挂起

JS 引擎线程和事件触发线程
浏览器页面初次渲染完毕后，JS引擎线程结合事件触发线程的工作流程如下：
* 同步任务在 JS 引擎线程（主线程）上执行，形成执行栈（Execution Content Stack）
* 主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务运行结果，就在任务队列之中放置一个事件。
* 执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。

事件触发管理的任务队列，是从JS引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步API时，会在任务队列中添加事件，栈中代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。

JS 中有两种任务类型： 微任务和宏任务，在 ES6 中，microtask 称为 jobs，macrotask 称为 task。
宏任务，setTimeout\setInterval\setImmediate\I/O\UI rendering
微任务，process.nextTick(Nodejs)\promise\Object.observe\MutationObserver

区别在于：
* 宏任务是每次执行栈执行的代码（每次从事件队列中获取一个事件回调并放到执行栈中执行）
* 浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务>渲染>宏任务）
* 微任务是在当前宏任务执行结束之后立即执行的任务（在当前宏任务执行之后，UI 渲染之前的任务）。微任务的响应速度相比 setTimeout（下一个宏任务）会更快，因为无需等待 UI 渲染
* 当前宏任务执行后，会将执行期间产生的微任务都执行一遍。

### Event Loop
event loops 规范中定义了浏览器何时进行渲染更新，有助于性能优化。
js 是单线程，但是浏览器不是，只是执行 js 代码的引擎是单线程，但是浏览器不是，只是执行 js 代码的引擎是个单线程的，所以 js 代码没有办法开启多个线程，所以在执行定时器、事件、ajax 这些异步事件的时候是另外三个线程在执行代码，并不是 js 引擎在执行，在这些线程达到某一特定事件把任务放入 js 引擎线程中，同时 GUI 线程（渲染界面 HTML 的线程）与 JS 线程是互斥的，在 JS 引擎执行时 GUI 线程会被冻结、挂起。
macrotask 宏任务：
* setTimeout
* setInterval
* setImmediate
* I/O
* UI rendering

microtask 微任务：
* process.nextTick
* promise
* Object.observe
* MutationObserver




### 事件循环流程
* 同步任务在 JS 引擎线程（主线程）上执行，形成执行栈，执行完同步任务后，执行栈是否为空
* 为空，检查微任务队列，如果有任务，一次性执行完微任务队列
* 如果微任务队列为空，检查宏任务队列，*每个*宏任务执行完毕，检查微任务队列，不为空，执行完微任务
* 微任务，宏任务执行中，有微任务、宏任务，添加进入队列，按原规则执行

附：浏览器为了能够使得 JS 引擎线程与 GUI 渲染线程有序切换，
会在当前宏任务结束之后，下一个宏任务执行开始之前，进行页面进行渲染（宏任务>渲染>宏任务），
微任务在当前宏任务执行之后，UI 渲染之前，
总结，微任务队列>宏任务>宏任务中产生微任务>渲染>宏任务


### 如何实现一个事件的发布订阅
// 先订阅
// 后发布，和 事件循环有关系嘛 ？？？

### 介绍一下事件的循环
js 避免多线程修改 dom，设计成单线程，其中有需要等待一段时间后才能执行的任务，比如请求等，为了避免任务阻塞，将任务设计成了同步任务、异步任务。
异步任务，有宏任务队列，微任务队列。

### 宏任务和微任务的区别
常见宏任务： setTimeout setInterval setImmediate I/O UI rendering
常见微任务：process.nextTick promise Object.observe   MutationObserver

附：
setImmediate 在浏览器，支持力度不大，执行顺序和 setTimeout 不确定
在 NodeJS 中，setTimeout 在 timer 阶段执行，setImmediate 在 check 阶段执行

### 浏览器和 Node Event Loop
浏览器和 Node 环境下，microtask 任务队列的执行时机不同
Node 端，microtask 在事件循环的各个阶段之间执行
浏览器，microtask 在时间循环的 mactotask 执行完之后执行

### Node Event Loop
Node 中的 Event Loop 和浏览器中的完全是不相同。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统的一些底层特性，对外提供统一的 API，事件循环机制也是里面实现的。
libuv 引擎中的事件循环分为 6 个阶段，回按照顺序反复运行。每当进入某个节点时候，都会从对应的回调队列中取出函数去执行。
* timer 阶段，执行 timer（setTimeout、setInterval）的回掉
* I/O callback 阶段，处理一些上一轮循环中的少数未执行的 I/O 回调
* idle，prepare 阶段，仅 node 内部使用
* poll 阶段，获取新的 I/O 事件，适当条件下 node 将阻塞在这
* check 阶段，执行 setImmediate 的回调
* close callbacks 阶段，执行 socket 的 close 事件回调

process.nextTick 不在上面 6 个阶段中，有自己的队列，每个阶段完成后，如果存在 nextTick 队列，会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

## 函数式编程
* 函数是“一等公民”，基本操作都是在操作函数；
* 声明式编程，接近自然语言，function add(x,y) { return x + y; }；
* 不可变了，不能使用 var、let ???
* 惰性执行，只在需要时候执行，不产生无意义的中间变量；
* 无状态和数据不可变，数据不可变，所有数据不可变，要修改一个对象，需要创建一个新对象用来修改，无状态，结果不变，完全不依赖外部状态变化；
* 没有副作用，即数据不可变；
* 纯函数，函数运行结果不依赖全局变量，不修改全局变量，不修改入参

### 柯里化
将多远函数，转换成一个依次调用的单元函数
```javascript
f(a,b,c) -> f(a)(b)(c)
```
实现
```javascript
const curry = fn => 
  judge = (...args) => 
  args.length === fn.length ? fn(...args) : arg => judge(...args, arg);
```

### 函数组成
将多个函数组成一个函数
```javascript
const compose = (f,g) => x => f(g(x));

const f = x => x+1;
const g = x => x*2;
const fg = compose(f,g);
fg(1) // 3
```

### 其他
Hindly Milner 类型签名，类似以下的说明，暴露函数的行为和目的，方便了解语义
:: String -> Object 

Pointfree 编程风格，强调整个函数编写过程中不出现参数，而只是通过函数组合生成新的函数

## PWA/service worker
PWA 渐近式网页应用，像普通网页一样加载，但是提供脱机工作、推送通知，和硬件访问功能。 
PWA 的核心技术包括：
* Web App Manifest 在主屏幕添加 app 图标，定义手机标题拦颜色之类
* Service Worker 缓存，离线开发，以及地理位置信息处理
* App Shell 先显示 APP 的主结构，再填充主数据，更快显示更好体验
* Push Notification 消息推送
Service Worker 仅仅是 PWA 技术中的一部分，又独立于 PWA。

service worker 离线开发
1. 在页面上注册一个 service worker
```javascript
  if('serviceWork' in navigator) {
    navigator.serviceWorker.register('./sw-demo-cache.js');
  }
```
2. sw-demo-cache.js 这个 JS 复制如下代码
```javascript
var VERSION = 'v1';

// 缓存
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(VERSION).then(function(cache) {
      return cache.addAll([
        './start.html',
        './static/jquery.min.js',
        './static/mm1.jpg'
      ]);
    })
  );
});

// 缓存更新
self.addEventListener('activate', function(event) {
  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          // 如果当前版本和缓存版本不一致
          if (cacheName !== VERSION) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// 捕获请求并返回缓存数据
self.addEventListener('fetch', function(event) {
  event.respondWith(caches.match(event.request).catch(function() {
    return fetch(event.request);
  }).then(function(response) {
    caches.open(VERSION).then(function(cache) {
      cache.put(event.request, response);
    });
    return response.clone();
  }).catch(function() {
    return caches.match('./static/mm1.jpg');
  }));
});
```

## web worker
javascript 单线程模型，Web Worker 为 Javascript 创建多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。
```javascript
// main.js
var worker = new Worker('./worker.js');

// 主线程向 Worker 发送消息
worker.postMessage('Hello World');

// 主线程通过 worker.onmessage 指定件套函数，接收子线程发回来的消息
worker.onmessage = function (event) {}

// 完成任务，主线程关闭
worker.terminate();

// ./worker.js
onmessage = e => {
  const message = e.data;
  postMessage('worker set message');
}
```
主要应用场景：
* 对于图像、视频、音频的解析处理
* canvas 图像计算处理
* 大量 ajax 请求或网络轮训
* 大量数据的计算处理

## 常用方法
* const/let 变量声明
* 箭头函数
  1. 箭头函数没有 arguments
  2. 箭头函数没有 prototype 属性，不能用做构造函数，不能用 new 构建函数
  3. 肩头函数没有自己 this，引用的是上下文的 this，即使使用 call、apply、bind 也无法改变
* 解构赋值，原理是消耗数组的迭代器，把生成对象的 value 属性的值赋值给对应变量
* 剩余/扩展运算符， 使用3个点(...)
* 对象属性简写， let obj = { x }
* for of 循环
  1. for ... of 只能用在可叠戴对象上，获取迭代器返回的 value
  2. for ... in 会遍历对象的整个原型链，性能非常差，不推荐
  3. 对于数组遍历 for ... in 回返回数组中所有可枚举属性，for ... of 只返回下标对应的属性值
  4. promise 异步编程管理
* Proxy，拦截器

### 数组方法
* for-in
* for-of es6

### ES6 后
ES7
boolean Array.prototype.includes 判断数组是否包含一个指定值
指数操作符， 2**10 = Math.pow(2,10)

ES8
* async/await 获取异步函数的返回值
* Object.values 返回 Object 自身属性所有值，不包括继承的值 
* Object.entries 函数返回一个给定对象的所有属性 key 和 value
  ```javascript
  for(let [key, value] of Object.entries(obj1)) {
    console.log(`key: ${key} value: ${value}`);
  }
  ```
* String.prototype.padStart 和 String.prototype.padEnd 允许将空字符串和其他字符串添加到原始字符串的开头或结尾
* 函数参数列表结尾允许逗号
* Object.getOwnPropertyDescriptions 用来获取一个对象所有自身属性的描述符

## 手写代码
https://juejin.cn/post/6844903856489365518 
？？？ 补充不，用处大不 ？


## Function
Function 构造函数创建一个新的 Function 对象，调用构造函数动态创建函数，但会遇到和 eval 类似的安全问题，和较小的性能问题，与 eval 不同，Function 创建函数只能在全局作用域中运行。


## 引用
https://mp.weixin.qq.com/s/m7eMwAKj0akwlpzh9Ye0pg
https://muyiy.cn/blog/
Javascript  https://github.com/mqyqingfeng/Blog/issues


相关文章链接
[1]
理解 JavaScript 中的执行上下文和执行栈: https://juejin.im/post/5ba32171f265da0ab719a6d7
[2]
JavaScript深入之执行上下文栈: https://github.com/mqyqingfeng/Blog/issues/4
[3]
一道js面试题引发的思考: https://github.com/kuitos/kuitos.github.io/issues/18
[4]
JavaScript深入之词法作用域和动态作用域: https://github.com/mqyqingfeng/Blog/issues/3
[5]
JavaScript深入之作用域链: https://github.com/mqyqingfeng/Blog/issues/6
[6]
发现 JavaScript 中闭包的强大威力: https://juejin.im/post/5c4e6a90e51d4552266576d2
[7]
JavaScript闭包的底层运行机制: http://blog.leapoahead.com/2015/09/15/js-closure/
[8]
我从来不理解JavaScript闭包，直到有人这样向我解释它...: https://zhuanlan.zhihu.com/p/56490498
[9]
破解前端面试（80% 应聘者不及格系列）：从闭包说起: https://juejin.im/post/58f1fa6a44d904006cf25d22#heading-0
[10]
JavaScript基础心法——this: https://github.com/axuebin/articles/issues/6
[11]
JavaScript深入之从ECMAScript规范解读this: https://github.com/mqyqingfeng/Blog/issues/7
[12]
前端基础进阶（七）：全方位解读this: https://www.jianshu.com/p/d647aa6d1ae6
[13]
面试官问：JS的this指向: https://juejin.im/post/5c0c87b35188252e8966c78a
[14]
JavaScript深入之call和apply的模拟实现: https://juejin.im/post/5907eb99570c3500582ca23c
[15]
JavaScript基础心法—— call apply bind: https://github.com/axuebin/articles/issues/7
[16]
面试官问：能否模拟实现JS的call和apply方法: https://juejin.im/post/5bf6c79bf265da6142738b29
[17]
回味JS基础:call apply 与 bind: https://juejin.im/post/57dc97f35bbb50005e5b39bd
[18]
面试官问：能否模拟实现JS的bind方法: https://juejin.im/post/5bec4183f265da616b1044d7
[19]
不用call和apply方法模拟实现ES5的bind方法: https://github.com/jawil/blog/issues/16
[20]
【THE LAST TIME】一文吃透所有JS原型相关知识点: https://juejin.im/post/5dba456d518825721048bce9
[21]
重新认识构造函数、原型和原型链: https://juejin.im/post/5c6a9c10f265da2db87b98f3
[22]
JavaScript深入之从原型到原型链: https://github.com/mqyqingfeng/blog/issues/2
[23]
最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）: https://www.jianshu.com/p/dee9f8b14771
[24]
最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）: https://www.jianshu.com/p/652991a67186
[25]
最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）: https://www.jianshu.com/p/a4e1e7b6f4f8
[26]
JavaScript 引擎基础：原型优化: https://hijiangtao.github.io/2018/08/21/Prototypes/
[27]
Prototypes in JavaScript: https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b
[28]
JavaScript深入之创建对象的多种方式以及优缺点: https://github.com/mqyqingfeng/Blog/issues/15
[29]
详解JS原型链与继承: http://louiszhai.github.io/2015/12/15/prototypeChain/
[30]
从__proto__和prototype来深入理解JS对象和原型链: https://github.com/creeperyang/blog/issues/9
[31]
代码复用模式: https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown
[32]
JavaScript 中的继承：ES3、ES5 和 ES6: http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/
[33]
你好，JavaScript异步编程---- 理解JavaScript异步的美妙: https://juejin.im/post/5b56c3586fb9a04faa79a8e0
[34]
Promise不会？？看这里！！！史上最通俗易懂的Promise！！！: https://juejin.im/post/5afe6d3bf265da0b9e654c4b
[35]
一起学习造轮子（一）：从零开始写一个符合Promises/A+规范的promise: https://juejin.im/post/5b16800fe51d4506ae719bae#heading-34
[36]
Promise实现原理（附源码）: https://juejin.im/post/5b83cb5ae51d4538cc3ec354
[37]
当 async/await 遇上 forEach: https://objcer.com/2017/10/12/async-await-with-forEach/
[38]
Promise 必知必会（十道题）: https://juejin.im/post/5a04066351882517c416715d
[39]
BAT前端经典面试问题：史上最最最详细的手写Promise教程: https://juejin.im/post/5b2f02cd5188252b937548ab#heading-9
[40]
JavaScript基础心法——深浅拷贝: https://github.com/axuebin/articles/issues/20
[41]
深拷贝的终极探索（90%的人都不知道）: https://juejin.im/post/5bc1ae9be51d450e8b140b0c
[42]
JavaScript专题之深浅拷贝: https://github.com/mqyqingfeng/Blog/issues/32
[43]
javaScript中浅拷贝和深拷贝的实现: https://github.com/wengjq/Blog/issues/3
[44]
深入剖析 JavaScript 的深复制: https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/
[45]
「JavaScript」带你彻底搞清楚深拷贝、浅拷贝和循环引用: https://segmentfault.com/a/1190000015042902
[46]
面试题之如何实现一个深拷贝: https://github.com/yygmind/blog/issues/29
[47]
Tasks, microtasks, queues and schedules: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
[48]
How JavaScript works: https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5
[49]
从event loop规范探究javaScript异步及浏览器更新渲染时机: https://github.com/aooy/blog/issues/5
[50]
这一次，彻底弄懂 JavaScript 执行机制: https://juejin.im/post/59e85eebf265da430d571f89
[51]
【THE LAST TIME】彻底吃透 JavaScript 执行机制: https://juejin.im/post/5d901418518825539312f587
[52]
一次弄懂Event Loop（彻底解决此类面试问题）: https://juejin.im/post/5c3d8956e51d4511dc72c200
[53]
浏览器与Node的事件循环(Event Loop)有何区别?: https://zhuanlan.zhihu.com/p/54882306
[54]
深入理解 JavaScript Event Loop: https://zhuanlan.zhihu.com/p/34229323
[55]
The Node.js Event Loop, Timers, and process.nextTick(): https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
[56]
函数式编程指北: https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/
[57]
JavaScript专题之函数柯里化: https://github.com/mqyqingfeng/Blog/issues/42
[58]
Understanding Functional Programming in Javascript: https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8
[59]
What is Functional Programming?: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0
[60]
简明 JavaScript 函数式编程——入门篇: https://juejin.im/post/5d70e25de51d453c11684cc4
[61]
You Should Learn Functional Programming: https://dev.to/allanmacgregor/you-should-learn-functional-programming-in-2018-4nff
[62]
JavaScript 函数式编程到底是个啥: https://segmentfault.com/a/1190000009864459
[63]
JavaScript-函数式编程: https://github.com/ecmadao/Coding-Guide/blob/master/Notes/JavaScript/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md
[64]
Service Worker：简介: https://developers.google.com/web/fundamentals/primers/service-workers
[65]
JavaScript 是如何工作的：Service Worker 的生命周期及使用场景: https://github.com/qq449245884/xiaozhi/issues/8
[66]
借助Service Worker和cacheStorage缓存及离线开发: https://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/
[67]
PWA Lavas 文档: https://lavas.baidu.com/pwa/README
[68]
PWA 学习手册: https://pwa.alienzhou.com/
[69]
面试官：请你实现一个PWA: https://juejin.im/post/5e26aa785188254c257c462d#heading-24
[70]
浅谈HTML5 Web Worker: https://juejin.im/post/59c1b3645188250ea1502e46
[71]
JavaScript 中的多线程 -- Web Worker: https://zhuanlan.zhihu.com/p/25184390
[72]
JavaScript 性能利器 —— Web Worker: https://juejin.im/post/5c10e5a9f265da611c26d634
[73]
A Simple Introduction to Web Workers in JavaScript: https://medium.com/young-coder/a-simple-introduction-to-web-workers-in-javascript-b3504f9d9d1c
[74]
Speedy Introduction to Web Workers: https://auth0.com/blog/speedy-introduction-to-web-workers/
[75]
近一万字的ES6语法知识点补充: https://juejin.im/post/5c6234f16fb9a049a81fcca5
[76]
ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南): https://juejin.im/post/5b9cb3336fb9a05d290ee47e
[77]
解锁多种JavaScript数组去重姿势: https://juejin.im/post/5b0284ac51882542ad774c45
[78]
Here’s how you can make better use of JavaScript arrays: https://www.freecodecamp.org/news/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c/
[79]
一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧: https://juejin.im/post/5cef46226fb9a07eaf2b7516
[80]
1.5万字概括ES6全部特性(已更新ES2020): https://juejin.im/post/5d9bf530518825427b27639d
[81]
position - CSS: Cascading Style Sheets | MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/position
[82]
position | CSS Tricks: https://css-tricks.com/almanac/properties/p/position/
[83]
杀了个回马枪，还是说说position:sticky吧: https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/
[84]
30 分钟学会 Flex 布局: https://zhuanlan.zhihu.com/p/25303493
[85]
css行高line-height的一些深入理解及应用: https://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/
[86]
A Complete Guide to Flexbox: https://css-tricks.com/snippets/css/a-guide-to-flexbox/
[87]
写给自己看的display: flex布局教程: https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/
[88]
从网易与淘宝的font-size思考前端设计稿与工作流: https://www.cnblogs.com/lyzg/p/4877277.html
[89]
细说移动端 经典的REM布局 与 新秀VW布局: https://cloud.tencent.com/developer/article/1352187
[90]
移动端1px解决方案: https://juejin.im/post/5d19b729f265da1bb2774865
[91]
Retina屏的移动设备如何实现真正1px的线？: https://jinlong.github.io/2015/05/24/css-retina-hairlines/
[92]
CSS retina hairline, the easy way.: http://dieulot.net/css-retina-hairline
[93]
浏览器的回流与重绘 (Reflow & Repaint): https://juejin.im/post/5a9923e9518825558251c96a
[94]
回流与重绘：CSS性能让JavaScript变慢？: https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/
[95]
CSS实现水平垂直居中的1010种方式（史上最全）: https://juejin.im/post/5b9a4477f265da0ad82bf921
[96]
干货!各种常见布局实现: https://juejin.im/post/5aa252ac518825558001d5de
[97]
CSS 常见布局方式: https://juejin.im/post/599970f4518825243a78b9d5
[98]
彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index: https://juejin.im/post/5b876f86518825431079ddd6
[99]
深入理解CSS中的层叠上下文和层叠顺序: https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/
[100]
Sass vs. Less: https://css-tricks.com/sass-vs-less/
[101]
2019年，你是否可以抛弃 CSS 预处理器？: https://aotu.io/notes/2019/10/29/css-preprocessor/index.html
[102]
浅谈 CSS 预处理器（一）：为什么要使用预处理器？: https://github.com/cssmagic/blog/issues/73
[103]
浏览器将rem转成px时有精度误差怎么办？: https://www.zhihu.com/question/264372456
[104]
Fighting the Space Between Inline Block Elements: https://css-tricks.com/fighting-the-space-between-inline-block-elements/
[105]
50行代码的MVVM，感受闭包的艺术: https://juejin.im/post/5b1fa77451882513ea5cc2ca
[106]
不好意思！耽误你的十分钟，让MVVM原理还给你: https://juejin.im/post/5abdd6f6f265da23793c4458
[107]
基于Vue实现一个简易MVVM: https://juejin.im/post/5cd8a7c1f265da037a3d0992
[108]
剖析Vue实现原理 - 如何实现双向绑定mvvm: https://github.com/DMQ/mvvm
[109]
Vue 生命周期源码剖析: https://ustbhuangyi.github.io/vue-analysis/v2/components/lifecycle.html
[110]
你真的理解 $nextTick么: https://juejin.im/post/5cd9854b5188252035420a13
[111]
React 源码剖析系列 － 生命周期的管理艺术: https://zhuanlan.zhihu.com/p/20312691
[112]
Vue 深入响应式原理: https://ustbhuangyi.github.io/vue-analysis/v2/reactive/
[113]
面试官: 实现双向绑定Proxy比defineproperty优劣如何?: https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf
[114]
Vuex、Flux、Redux、Redux-saga、Dva、MobX: https://zhuanlan.zhihu.com/p/53599723
[115]
10行代码看尽redux实现: https://juejin.im/post/5def4831e51d45584b585000
[116]
Mobx 思想的实现原理，及与 Redux 对比: https://zhuanlan.zhihu.com/p/25585910
[117]
使用原生 JavaScript 构建状态管理系统: https://juejin.im/post/5b763528e51d45559e3a5b64
[118]
vue中8种组件通信方式, 值得收藏!: https://juejin.im/post/5d267dcdf265da1b957081a3
[119]
Vue 组件间通信六种方式（完整版）: https://juejin.im/post/5cde0b43f265da03867e78d3
[120]
Vue组件间通信: https://github.com/answershuto/learnVue/blob/master/docs/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.MarkDown
[121]
Vue Virtual DOM 源码剖析: https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/virtual-dom.html
[122]
面试官: 你对虚拟DOM原理的理解?: https://juejin.im/post/5d3f3bf36fb9a06af824b3e2
[123]
让虚拟DOM和DOM-diff不再成为你的绊脚石: https://juejin.im/post/5c8e5e4951882545c109ae9c
[124]
探索Virtual DOM的前世今生: https://zhuanlan.zhihu.com/p/35876032
[125]
详解vue的diff算法: https://juejin.im/post/5affd01551882542c83301da
[126]
Deep In React 之详谈 React 16 Diff 策略(二): https://juejin.im/post/5d3e3231e51d4510926a7c39
[127]
React 源码剖析系列 － 不可思议的 react diff: https://zhuanlan.zhihu.com/p/20346379
[128]
浅入浅出图解 Dom Diff: https://juejin.im/post/5ad550f06fb9a028b4118d99
[129]
Vue 计算属性 VS 侦听属性源码剖析: https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html
[130]
Vue.js的computed和watch是如何工作的？: https://juejin.im/post/5b87f13bf265da436479f3c1
[131]
React Hooks 原理: https://github.com/brickspert/blog/issues/26
[132]
React hooks: not magic, just arrays: https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e
[133]
Deep dive: How do React hooks really work?: https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/
[134]
【React深入】从Mixin到HOC再到Hook: https://juejin.im/post/5cad39b3f265da03502b1c0a
[135]
React Hooks 详解 【近 1W 字】+ 项目实战: https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d
[136]
30分钟精通React今年最劲爆的新特性——React Hooks: https://segmentfault.com/a/1190000016950339
[137]
React Hooks 详解（一）: http://huayifeng.top:2368/react-hooks/
[138]
探索Vue高阶组件: http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/
[139]
React 高阶组件(HOC)入门指南: https://juejin.im/post/5914fb4a0ce4630069d1f3f6
[140]
深入理解 React 高阶组件: https://zhuanlan.zhihu.com/p/24776678
[141]
前端工程师都得掌握的 webpack Loader: https://github.com/axuebin/articles/issues/38
[142]
手把手教你撸一个简易的 webpack: https://juejin.im/post/5b192afde51d45069c2efe5a
[143]
带你走进webpack世界，成为webpack头号玩家。: https://juejin.im/post/5ac9dc9af265da23884d5543
[144]
手把手教你撸一个 Webpack Loader: https://juejin.im/post/5a698a316fb9a01c9f5b9ca0
[145]
webpack 如何通过作用域分析消除无用代码: https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis
[146]
【webpack进阶】你真的掌握了loader么？- loader十问: https://juejin.im/post/5bc1a73df265da0a8d36b74f
[147]
Webpack小书: https://www.timsrc.com/article/2/webpack-book
[148]
聊一聊webpack-dev-server和其中socket，HMR的实现: https://github.com/879479119/879479119.github.io/issues/5
[149]
使用webpack4提升180%编译速度: http://louiszhai.github.io/2019/01/04/webpack4
[150]
Webpack 大法之 Code Splitting: https://zhuanlan.zhihu.com/p/26710831
[151]
轻松理解webpack热更新原理: https://juejin.im/post/5de0cfe46fb9a071665d3df0
[152]
揭秘webpack plugin: https://champyin.com/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/
[153]
不容错过的 Babel7 知识: https://juejin.im/post/5ddff3abe51d4502d56bd143
[154]
前端工程师需要了解的 Babel 知识: https://www.zoo.team/article/babel
[155]
深入浅出 Babel 上篇：架构和原理 + 实战: https://juejin.im/post/5d94bfbf5188256db95589be
[156]
深入浅出 Babel 下篇：既生 Plugin 何生 Macros: https://juejin.im/post/5da12397e51d4578364f6ffa
[157]
前端工程师的自我修养-关于 Babel 那些事儿: https://juejin.im/post/5e5b488af265da574112089f
[158]
前端与编译原理——用JS写一个JS解释器: https://segmentfault.com/a/1190000017241258
[159]
编写一个简单的JavaScript模板引擎: https://www.liaoxuefeng.com/article/1006272230979008
[160]
JavaScript模板引擎原理，几行代码的事儿: https://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html
[161]
Vue 模板编译原理: https://github.com/berwin/Blog/issues/18
[162]
JavaScript template engine in just 20 lines: https://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line
[163]
Understanding JavaScript Micro-Templating: https://medium.com/wdstack/understanding-javascript-micro-templating-f37a37b3b40e
[164]
大公司里怎样开发和部署前端代码？: https://www.zhihu.com/question/20790576
[165]
前端高级进阶：前端部署的发展历程: https://juejin.im/post/5e6836cc51882549052f56f5
[166]
深入了解 Weex: https://juejin.im/post/5b18a03ce51d45069d2263e3
[167]
Weex原理概述: https://github.com/weexteam/article/issues/32
[168]
Weex 是如何在 iOS 客户端上跑起来的: https://halfrost.com/weex_ios/
[169]
详解 Weex 页面的渲染过程: https://segmentfault.com/a/1190000010415641
[170]
JSBridge 介绍及实现原理: http://coolnuanfeng.github.io/jsbridge
[171]
5 分钟撸一个前端性能监控工具: https://juejin.im/post/5b7a50c0e51d4538af60d995
[172]
把前端监控做到极致: https://zhuanlan.zhihu.com/p/32262716
[173]
GMTC 大前端时代前端监控的最佳实践: https://juejin.im/post/5b35921af265da598f1563cf
[174]
前端监控和前端埋点方案设计: https://juejin.im/post/5b62d68df265da0f9d1a1cd6
[175]
Webpack优化——将你的构建效率提速翻倍: https://juejin.im/post/5d614dc96fb9a06ae3726b3e
[176]
性能优化篇---Webpack构建速度优化: https://segmentfault.com/a/1190000018493260
[177]
webpack构建速度与结果优化: https://huangxsu.com/2018/08/12/webpack-optimization/
[178]
让你的Webpack起飞—考拉会员后台Webpack优化实战: https://zhuanlan.zhihu.com/p/42465502
[179]
webpack dllPlugin打包体积和速度优化: https://zhuanlan.zhihu.com/p/39727247
[180]
使用webpack4提升180%编译速度: http://louiszhai.github.io/2019/01/04/webpack4/
[181]
Webpack 打包优化之速度篇: https://www.jeffjade.com/2017/08/12/125-webpack-package-optimization-for-speed/
[182]
多进程并行压缩代码: https://jkfhto.github.io/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81/
[183]
Tree-Shaking性能优化实践 - 原理篇: https://juejin.im/post/5a4dc842518825698e7279a9
[184]
体积减少80%！释放webpack tree-shaking的真正潜力: https://juejin.im/post/5b8ce49df265da438151b468
[185]
你的Tree-Shaking并没什么卵用: https://zhuanlan.zhihu.com/p/32831172
[186]
webpack 如何通过作用域分析消除无用代码: https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis
[187]
加速Webpack-缩小文件搜索范围: https://imweb.io/topic/5a40551ea192c3b460fce335
[188]
Brief introduction to scope hoisting in Webpack: https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f
[189]
通过Scope Hoisting优化Webpack输出: https://imweb.io/topic/5a43064fa192c3b460fce360
[190]
webpack 的 scope hoisting 是什么？: https://ssshooter.com/2019-02-20-webpack-scope-hoisting/
[191]
webpack优化之code splitting: https://segmentfault.com/a/1190000013000463
[192]
webpack 4: Code Splitting和chunks切分优化: https://juejin.im/post/5d53f49bf265da03dc0766e2
[193]
Webpack 大法之 Code Splitting: https://zhuanlan.zhihu.com/p/26710831
[194]
Better tree shaking with deep scope analysis: https://medium.com/webpack/better-tree-shaking-with-deep-scope-analysis-a0b788c0ce77
[195]
Front-End Performance Checklist 2020: https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages/#top
[196]
（译）2019年前端性能优化清单 — 上篇: https://juejin.im/post/5c46cbaee51d453f45612a2c
[197]
网站性能优化实战——从12.67s到1.06s的故事: https://juejin.im/post/5b6fa8c86fb9a0099910ac91
[198]
浏览器页面资源加载过程与优化: https://juejin.im/post/5a4ed917f265da3e317df515
[199]
聊聊前端开发中的长列表: https://zhuanlan.zhihu.com/p/26022258
[200]
再谈前端虚拟列表的实现: https://zhuanlan.zhihu.com/p/34585166
[201]
浅说虚拟列表的实现原理: https://github.com/dwqs/blog/issues/70
[202]
浏览器IMG图片原生懒加载loading=”lazy”实践指南: https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/
[203]
用 preload 预加载页面资源: https://juejin.im/post/5a7fb09bf265da4e8e785c38
[204]
Preload, Prefetch And Priorities in Chrome: https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf
[205]
Front-End Performance Checklist  : https://github.com/thedaviddias/Front-End-Performance-Checklist
[206]
图片与视频懒加载的详细指南: https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/
[207]
使用 Intersection Observer 来懒加载图片: http://deanhume.com/lazy-loading-images-using-intersection-observer/
[208]
为什么要在javascript中进行静态类型检查: https://www.jianshu.com/p/bda750e2d15e
[209]
TypeScript Start: 基础类型: https://github.com/axuebin/articles/issues/36
[210]
TypeScript 中高级应用与最佳实践: http://www.alloyteam.com/2019/07/13796/
[211]
可能是你需要的 React + TypeScript 50 条规范和经验: https://juejin.im/post/5ce24f8ae51d45106477bd45
[212]
从 JavaScript 到 TypeScript: https://juejin.im/post/5958fdd7f265da6c40735085
[213]
TypeScript + 大型项目实战: https://juejin.im/post/5b54886ce51d45198f5c75d7
[214]
TypeScript - 一种思维方式: https://juejin.im/post/5cd6387d518825682348442d
[215]
如何编写一个d.ts文件: https://segmentfault.com/a/1190000009247663
[216]
TypeScript 的声明文件的使用与编写: https://my.oschina.net/fenying/blog/748805
[217]
TypeScript 进阶：给第三方库编写声明文件: http://imzc.me/dev/2016/11/30/write-d-ts-files/
[218]
TypeScript泛型: https://jkchao.github.io/typescript-book-chinese/typings/generices.html
[219]
TypeScript 重构 Axios 经验分享: https://juejin.im/post/5bf7f1c0e51d455ed74f625c
[220]
手把手教写 TypeScript Transformer Plugin: https://juejin.im/post/5a0a54425188253edc7f6e79
[221]
听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？: https://zhuanlan.zhihu.com/p/25028045
[222]
前端基础篇之HTTP协议: https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2
[223]
都9102年了，还问GET和POST的区别: https://segmentfault.com/a/1190000018129846
[224]
HTTP 响应代码 | MDN: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status
[225]
如何理解HTTP响应的状态码？: https://harttle.land/2015/08/15/http-status-code.html#header-11
[226]
你所知道的3xx状态码: https://aotu.io/notes/2016/01/28/3xx-of-http-status/index.html
[227]
浏览器缓存: https://github.com/xiangxingchen/blog/issues/9
[228]
HTTP协议头部与Keep-Alive模式详解: https://www.byvoid.com/zhs/blog/http-keep-alive-header
[229]
HTTP keep-alive 二三事: https://lotabout.me/2019/Things-about-keepalive/
[230]
深入理解HTTPS工作原理: https://juejin.im/post/5ca6a109e51d4544e27e3048
[231]
九个问题从入门到熟悉HTTPS: https://juejin.im/post/5a2ff29c6fb9a045132aac5a
[232]
谈谈 HTTPS: https://juejin.im/post/59e4c02151882578d02f4aca
[233]
看图学HTTPS: https://juejin.im/post/5b0274ac6fb9a07aaa118f49
[234]
分分钟让你理解HTTPS: https://juejin.im/post/5ad6ad575188255c272273c4
[235]
解密HTTP/2与HTTP/3 的新特性: https://segmentfault.com/a/1190000020714686#articleHeader16
[236]
浅谈 HTTP/2 Server Push: https://zhuanlan.zhihu.com/p/26757514
[237]
HTTP2基本概念学习笔记: https://juejin.im/post/5acccf966fb9a028d043c6ec
[238]
写给前端工程师的DNS基础知识: http://www.sunhao.win/articles/netwrok-dns.html
[239]
前端优化: DNS预解析提升页面速度: https://www.jianshu.com/p/95a0c0636d28
[240]
DNS解析: https://imweb.io/topic/55e3ba46771670e207a16bc8
[241]
通俗大白话来理解TCP协议的三次握手和四次分手: https://github.com/jawil/blog/issues/14
[242]
就是要你懂 TCP: http://jm.taobao.org/2017/06/08/20170608/
[243]
TCP协议详解: https://juejin.im/post/5ba895a06fb9a05ce95c5dac
[244]
面试时，你被问到过 TCP/IP 协议吗?: https://juejin.im/post/58e36d35b123db15eb748856
[245]
“三次握手，四次挥手”你真的懂吗？: https://zhuanlan.zhihu.com/p/53374516
[246]
五分钟了解CDN: https://juejin.im/post/5afa449c51882542ba07e70e
[247]
漫话：如何给女朋友解释什么是CDN？: https://juejin.im/post/5d478c48e51d453c135c5a5c
[248]
关于 cdn、回源等问题一网打尽: https://juejin.im/post/5af46498f265da0b8d41f6a3
[249]
CDN是什么？使用CDN有什么优势？: https://www.zhihu.com/question/36514327?rf=37353035
[250]
从输入URL到页面展示，这中间发生了什么？: https://time.geekbang.org/column/article/117637
[251]
前端经典面试题: 从输入URL到页面加载发生了什么？: https://segmentfault.com/a/1190000006879700
[252]
Javascript常用的设计模式详解: https://www.cnblogs.com/tugenhua0707/p/5198407.html
[253]
JavaScript设计模式: https://juejin.im/post/59df4f74f265da430f311909
[254]
JavaScript 中常见设计模式整理: https://juejin.im/post/5afe6430518825428630bc4d
[255]
JavaScript 常见设计模式解析: https://juejin.im/post/58f4c702a0bb9f006aa80f25
[256]
深入 JavaScript 设计模式，从此有了优化代码的理论依据: https://juejin.im/post/5d58ca046fb9a06ad0056cc7
[257]
设计模式之美-前端: https://zhuanlan.zhihu.com/p/111553641
[258]
Linked Lists in JavaScript (ES6 code): https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3
[259]
DS with JS — Linked Lists — II: https://medium.com/dev-blogs/ds-with-js-linked-lists-ii-3b387596e27e
[260]
LeetCode List: https://zxi.mytechroad.com/blog/leetcode-list/
[261]
JS中的算法与数据结构——链表(Linked-list): https://www.jianshu.com/p/f254ec665e57
[262]
前端笔试&面试爬坑系列---算法: https://juejin.im/post/5b72f0caf265da282809f3b5
[263]
漫画：什么是红黑树？: https://juejin.im/post/5a27c6946fb9a04509096248
[264]
前端你应该了解的数据结构与算法: https://juejin.im/post/5b331bc7f265da598451fd88
[265]
数据结构和算法在前端领域的应用（前菜）: https://juejin.im/post/5d3dc8466fb9a07efc49d0a9
[266]
数据结构与算法在前端领域的应用 - 第二篇: https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/
[267]
JavaScript 数据结构与算法之美: https://github.com/biaochenxuying/blog/issues/43
[268]
前端安全系列（一）：如何防止XSS攻击？: https://tech.meituan.com/2018/09/27/fe-security.html
[269]
前端安全系列（二）：如何防止CSRF攻击？: https://tech.meituan.com/2018/10/11/fe-security-csrf.html
[270]
Security: https://almanac.httparchive.org/en/2019/security
[271]
前端也需要了解的 JSONP 安全: https://juejin.im/post/5b75b497e51d45666276251d
[272]
【面试篇】寒冬求职之你必须要懂的Web安全: https://juejin.im/post/5cd6ad7a51882568d3670a8e
[273]
谈谈对 Web 安全的理解: https://zhuanlan.zhihu.com/p/25486768?group_id=820705780520079360
[274]
程序员必须要了解的web安全: https://juejin.im/post/5b4e0c936fb9a04fcf59cb79
[275]
可信前端之路：代码保护: https://www.freebuf.com/articles/web/102269.html
[276]
前端如何给 JavaScript 加密（不是混淆）？: https://www.zhihu.com/question/47047191
[277]
常见 Web 安全攻防总结: https://zoumiaojiang.com/article/common-web-security/
[278]
一篇文章构建你的 NodeJS 知识体系: https://juejin.im/post/5c4c0ee8f265da61117aa527
[279]
真-Node多线程: https://juejin.im/post/5c63b5676fb9a049ac79a798
[280]
浏览器与Node的事件循环(Event Loop)有何区别?: https://zhuanlan.zhihu.com/p/54882306
[281]
聊聊 Node.js RPC: https://www.yuque.com/egg/nodejs/dklip5
[282]
Understanding Streams in Node.js: https://nodesource.com/blog/understanding-streams-in-nodejs
[283]
如何通过饿了么 Node.js 面试: https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn
[284]
字节跳动面试官：请你实现一个大文件上传和断点续传: https://juejin.im/post/5dff8a26e51d4558105420ed
[285]
深入浅出浏览器渲染原理: https://zhuanlan.zhihu.com/p/53913989
[286]
前端开发如何独立解决跨域问题: https://segmentfault.com/a/1190000010719058
[287]
探索 Serverless 中的前端开发模式: https://juejin.im/post/5cdc3dc2e51d453b6c1d9d3a
[288]
「NGW」前端新技术赛场：Serverless SSR 技术内幕: https://juejin.im/post/5dce7140f265da0bf80b5246?utm_source=gold_browser_extension
[289]
JavaScript与Unicode: https://cjting.me/web2.0/js-and-unicode/
[290]
九种跨域方式实现原理（完整版）: https://juejin.im/post/5c23993de51d457b8c1f4ee1
[291]
7分钟理解JS的节流、防抖及使用场景: https://juejin.im/post/5b8de829f265da43623c4261
[292]
浏览器的工作原理：新式网络浏览器幕后揭秘: https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/
[293]
Different Types Of Observers Supported By Modern Browsers: https://www.zeolearn.com/magazine/different-types-of-observers-supported-by-modern-browsers
[294]
浏览器同源策略与ajax跨域方法汇总: https://www.jianshu.com/p/438183ddcea8
[295]
一年半经验如何准备阿里巴巴 P6 前端面试: https://juejin.im/post/5e5522b36fb9a07ce152c51c
[296]
面试分享：两年工作经验成功面试阿里P6总结: https://juejin.im/post/5d690c726fb9a06b155dd40d
[297]
总结了17年初到18年初百场前端面试的面试经验(含答案): https://juejin.im/post/5b44a485e51d4519945fb6b7
[298]
2018春招前端面试: 闯关记(精排精校) | 掘金技术征文: https://juejin.im/post/5a998991f265da237f1dbdf9
[299]
20道JS原理题助你面试一臂之力！: https://juejin.im/post/5d2ee123e51d4577614761f8
[300]
一年半经验，百度、有赞、阿里前端面试总结: https://juejin.im/post/5befeb5051882511a8527dbe
[301]
22 道高频 JavaScript 手写面试题及答案: https://juejin.im/post/5d51e16d6fb9a06ae17d6bbc
[302]
面试分享：专科半年经验面试阿里前端P6+总结(附面试真题及答案): https://juejin.im/post/5a92c23b5188257a6b06110b
[303]
写给 女朋友的中级前端面试秘籍: https://juejin.im/post/5e7af0685188255dcf4a497e
[304]
阿里前端攻城狮们写了一份前端面试题答案，请查收: https://juejin.im/post/5e7426d15188254967069c00
[305]
字节跳动今日头条前端面经（4轮技术面+hr面）: https://juejin.im/post/5e6a14b1f265da572978a1d3
[306]
「面试题」20+Vue面试题整理(持续更新): https://juejin.im/post/5e649e3e5188252c06113021
[307]
「吐血整理」再来一打Webpack面试题(持续更新): https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5
[308]
高级前端开发者必会的34道Vue面试题系列: https://juejin.im/post/5e7410ed51882549087dc365